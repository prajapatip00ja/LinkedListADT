#!/usr/bin/env node
var child = require('child_process');
var _ = require('lodash');
var fs = require('fs');
var path = require('path');
var pkg = require('../package');
var readTemplate = function(name){
	return fs.readFileSync(path.join(__dirname, '..', 'templates', name), 'utf-8');
};
var testRunnerSrc = readTemplate('TestRunner.c');
var allSourceFiles;
var testDetails ;
var testNamePatterns;
var _trace;

var exec = function(cmd,callback){
	child.exec(cmd,function(error,stdout,stderr){
		trace(cmd);
		trace('\t=>');
		error && trace('\terror:',error);
		stdout && trace('\tstdout:',stdout);
		stderr && trace('\tstderr:',stderr);
		callback(error,stdout,stderr);
	});
};

var isSymbolLine = function(line){return line.match(/^\[/);};
var toSymbol = function(line){return _.last(line.split(' _'));};
var is_a_test_method = function(symbol){return symbol.match(/^test_/);};
var trace = function(){
	if(!_trace) return;
	console.log.apply(null,_.values(arguments));
};
var matchesSomePattern = function(method){
	return _.some(testNamePatterns,function(pattern){return method.match(pattern);});
};
var readMethods = function(objdumpSyms){
	var all = objdumpSyms.split('\n').filter(isSymbolLine).map(toSymbol);
	var methods = all.filter(is_a_test_method);
	var fileName = _.last(all[0].split(' '));
	trace(fileName,'=>',methods);
	if(testNamePatterns){
		methods = methods.filter(matchesSomePattern);
		trace('matching:', methods);
	}
	return {
		tests: methods,
		hasSetup:_.contains(all,'setup'),
		hasTearDown:_.contains(all,'teardown')
	};
};
var toCurrentDir = function(file){return _.last(file.split('/'));};
var createTestDetail = function(name){	
	var localName = toCurrentDir(name);
	var cmdArgs = {
		testSrc: name,
		testObjFile: localName.replace(/Test.c$/,'Test.o'),
		runnerSrc: localName.replace(/Test.c$/,'TestRunner.c'),
		runnerExe: localName.replace(/Test.c$/,'TestRunner.exe'),
		srcs: allSourceFiles.join(' ')
	};
	var testDetail = {
		name:name,
		runner:cmdArgs.runnerSrc,
		runnerCore: cmdArgs.runnerExe+'.core',
		cmd: {
			clean_old_files: _.template('rm -f ${testObjFile} ${runnerSrc} ${runnerExe} ${runnerExe}.core',cmdArgs),
			read_test_methods: _.template('gcc -c ${testSrc} && objdump --syms ${testObjFile}',cmdArgs),
			runner_compile: _.template('gcc -g -o ${runnerExe} ${runnerSrc} ${testSrc} ${srcs}',cmdArgs),
			run: _.template('${runnerExe}',cmdArgs),
			locate: _.template('addr2line -f -s -e ${runnerExe}',cmdArgs)
		},
		step: -1,
		error:{}
	};
	return testDetail;
};
var step0_clean_old_files = function(testDetail){
	trace('step0_clean_old_files:',testDetail.name);
	var onClean = function(error,stdout,stderr){
		if(error) testDetail.error.clean_old_files = stderr;
		testDetail.step = 0;
		if(_.every(testDetails,{step:0})) step0_complete();
	};
	var cmd = testDetail.cmd.clean_old_files;
	trace(cmd);
	exec(cmd,onClean);
};

var step0_complete = function(){
	trace('step0_complete\n');
	var checkError = function(td){
		var error = td.error.clean_old_files;
		if(error) console.log(error);
		return error;
	};
	if(_.some(testDetails,checkError)) return;
	testDetails.forEach(step1_read_test_methods);
};
var step1_read_test_methods = function(testDetail){
	trace('step1_read_test_methods:',testDetail.name);
	var onCompile = function(error,stdout,stderr){
		if(error) {
			testDetail.error.read_test_methods = stderr;
			console.log(stderr);
			return;
		}
		var methods = readMethods(stdout);
		testDetail.methods = methods;
		testDetail.step = 1;
		if(_.every(testDetails,{step:1})) step1_complete();
	};
	var cmd = testDetail.cmd.read_test_methods;
	trace(cmd);
	exec(cmd,onCompile);
};
var filterMethodsByPattern = function(testDetail){

};
var step1_complete = function(){
	trace('step1_complete\n');
	var checkError = function(td){
		var error = td.error.read_test_methods;
		if(error) console.log(error);
		return error;
	};
	if(_.some(testDetails,checkError)) return;
	var hasMethods = function(td){
		if(td.methods.tests.length) return true;
		console.log('**----- ',td.name,' -------');
		return false;
	};
	testDetails = testDetails.filter(hasMethods);
	testDetails.forEach(filterMethodsByPattern);

	//filter out non pattern matches here.
	testDetails.forEach(step2_generateTestRunner);
};
var step2_generateTestRunner = function(testDetail){
	trace('step2_generateTestRunner:',testDetail.name);

	var src = testRunnerSrc.replace(/\/\*TEST_FUNCTIONS\*\//,','+testDetail.methods.tests.join(','));
	src = src.replace(/\/\*TEST_NAME_FUNCTION_PAIRS\*\//,testDetail.methods.tests.map(to_name_fn_pair).join(','));
	src = src.replace(/\/\*TEST_FILE_NAME\*\//,testDetail.name);
	if(testDetail.methods.hasSetup){
		src = src.replace(/\/\*CALL_SETUP\*\//,'setup();');
	}
	if(testDetail.methods.hasTearDown){
		src = src.replace(/\/\*CALL_TEARDOWN\*\//,'teardown();');
	}
	fs.writeFile(testDetail.runner,src,function(err){
		testDetail.generatedRunner = true;
		testDetail.step = 2;
		if(_.every(testDetails,{step:2})) step2_complete();
	});
};
var step2_complete = function(){
	trace('step2_complete\n');
	testDetails = _.filter(testDetails,'generatedRunner');
	testDetails.forEach(step3_compileTestRunner);
};
var step3_compileTestRunner = function(testDetail, index){
	trace('step3_compileTestRunner:',testDetail.name);
	var onCompile = function(error,stdout,stderr){
		if(error) testDetail.error.runner_compile = stderr;
		testDetail.step = 3;
		if(_.every(testDetails,{step:3})) step3_complete();
	};
	var cmd = testDetail.cmd.runner_compile;
	trace(cmd);
	exec(cmd,onCompile);
};
var step3_complete = function(){
	trace('step3_complete\n');
	var checkError = function(td){
		var error = td.error.runner_compile;
		if(error) console.log(error);
		return error;
	};
	if(_.some(testDetails,checkError)) return;
	testDetails.forEach(step4_run);
};
var step4_run = function(testDetail,index){
	trace('step4_run:',testDetail.name);
	var onRun = function(error,stdout,stderr){
		if(error) testDetail.error.run = stderr;
		testDetail.result = stdout;
		testDetail.step = 4;
		if(_.every(testDetails,{step:4})) step4_complete();
	};
	var cmd = testDetail.cmd.run;
	trace(cmd);
	exec(cmd,onRun);
};

var summarize = function(td){
	var summary = {total:'-',passed:'-',failed:'-'};
	var line = _.last(td.result.split('\n'),2)[0];
	var parts = line.split(' ');
	if(parts[1] === 'Ran'){
		summary.total = parts[2];
		summary.passed = parts[5];
		summary.failed = parts[7];
	}
	td.summary = summary;
};

var step4_complete = function(){
	trace('step4_complete\n');
	testDetails.forEach(function(td){
		console.log(td.result);
		summarize(td);
		step5_reportCrashLocation(td);
	});
};

var hasCoreDump = function(td){
	if(!td.error.run) return false;
	var lastLine = _.last(td.error.run.split('\n'),2)[0];
	return td.error.run.indexOf(td.runnerCore)>=0;
};
var suggestion = '** use "expr_assert.h" instead of <assert.h> to avoid aborting tests on assertion failure\n';
var step5_reportCrashLocation = function(td){
	if(!hasCoreDump(td)){
		if(td.error.run){
			console.log(td.error.run);
			var lastLine = _.last(td.error.run.split('\n'),2)[0];
			if(lastLine.match(/^assertion /)) console.log(suggestion);
		}
		td.step = 5;
		if(_.every(testDetails,{step:5})) step5_complete();
		return;
	}
	var lines = fs.readFileSync(td.runnerCore,'utf-8').split('\n');
	var address = _.last(lines[1].split(' '));
	var exception = _.last(lines[4].split(' '));
	var onLocated = function(error,stdout){
		if(error) console.log(error);
		var parts = stdout.split('\n');
		console.log('Exception:',exception,'in function',parts[0],'at',parts[1]);
		td.step = 5;
		if(_.every(testDetails,{step:5})) step5_complete();
	};
	var cmd = td.cmd.locate+' '+address;
	trace(cmd);
	exec(cmd,onLocated);
};

var step5_complete = function(){
	console.log('_______________________________________');
	console.log('\tSummary');
	console.log('_______________________________________');
	console.log('Total','\tPass','\tFail','\tTest');
	console.log('_______________________________________');
	testDetails.forEach(function(td){
		console.log('',td.summary.total,'\t',td.summary.passed,'\t',td.summary.failed,'\t',td.name);
	});
	console.log('_______________________________________');
};

var to_name_fn_pair = function(name){
	return _.template('"${name}",${name}',{name:name});
};
var is_a_test_file = function(name){ return name.match(/Test.c$/);};
var is_a_src_or_obj_file = function(name){
	return !name.match(/TestRunner.c$/) && !name.match(/Test.c$/) && name.match(/.[co]$/);
};
var readTestPatterns = function(){
	var patterns = [];
	args.forEach(function(name){
		var matches = name.match(/^{(.*)}$/);
		if(matches) patterns.push(matches[1]);
	});
	if(patterns.length) testNamePatterns = patterns;
};
var main = function(){
	allSourceFiles = args.filter(is_a_src_or_obj_file);
	testDetails = args.filter(is_a_test_file).map(createTestDetail);
	readTestPatterns();
	if(testDetails.length)
		testDetails.forEach(step0_clean_old_files);
	else
		console.log('no test files');
};
var showVersion = function(){
	console.log(pkg.name,pkg.version);
};
var showHelp = function(){
	showVersion();
	console.log(pkg.description);
	console.log('	---usage---');
	console.log('ctest -v');
	console.log('ctest --help');
	console.log('ctest --sample');
	console.log('ctest justTest.c');
	console.log('ctest mathTest.c math.c');
	console.log('ctest mathTest.c math.c {test_add_1_1_is_2}');
	console.log('ctest *.c');
	console.log('ctest *.c {add} {^test_subtract}');
	console.log('ctest mathTest.dc math.o');

};
var copyTemplate = function(name){
	fs.writeFile(name,readTemplate(name));
};
var generateSample = function(){
	copyTemplate('expr_assert.h');
	copyTemplate('sampleTest.c');
	console.log('----- generated expr_assert.h and sampleTest.c');
	console.log('now run ctest sampleTest.c');
};
//main code
var args = process.argv.splice(2);
if(_.contains(args,'--trace')) _trace = true;
if(args[0] === '-v') showVersion();
else if(args[0] === '--help') showHelp();
else if(args[0] === '--sample') generateSample();
else main();
//try in mac. objdump not available in mac